# Двоична пирамида. Приоритетна опашка

## Двоична пирамида (Binary heap)

***Дефиниция:*** **Попълнено двоично дърво (Complete binary tree)** е наредено двоично дърво, в което:  
- Всички нива, с изключение, може би, на последното, имат максималния възможен брой върхове.  
- Ако листата са на две нива, листата на последното ниво са максимално вляво.  

![alt_text](https://i.ibb.co/TcWpjN5/Complete-binary-tree.png)

***Дефиниция:*** **Двоична пирамида (Binary heap)** е попълнено двоично дърво, в което:  
- Или ключът на всеки връх е *по-голям или равен* на ключовете на неговите деца и тогава пирамидата е _**максимална пирамида (max heap)**_,  
- или ключът на всеки връх е *по-малък или равен* на ключовете на неговите деца и тогава пирамидата е _**минимална пирамида (min heap)**_.  

![alt_text](https://i.ibb.co/J79WV0z/Binary-heap.png)

## Реализация на двоична пирамида

Ще реализираме двоична пирамида *чрез масив*, който ще наричаме ***линеаризация*** на пирамидата.  
Линеаризирането можем да си представяме като обхождане на дървото (пирамида) по нива отляво надясно и последователно записване на ключовете в масива.  
Например, линеаризация на пирамидата от горната картинка е масивът **[10, 8, 9, 3, 2, 1]**.  

Тъй като дървото е попълнено, в масива няма как да има "дупки".  
***Предимството на тази реализация е, че се избягва разхода на памет.*** Ако искаме да представим двоично дърво в общия случай, не непременно попълнено, трябва по някакъв начин да укажем за всеки връх кой е родителят или кои са децата. Това ни струва допълнителна памет.  

Нека T е пирамида с n елемента и масивът A[0,..,n-1] е нейната линеаризация. Тогава за всеки елемент A[i]:  
 - Елементът, който отговаря на **родителя на A[i], e A[(i - 1) / 2]**, ако върхът на T, който отговаря на A[i], не е коренът.  
 - Елементът, който отговаря на **лявото дете на A[i], e A[2\*i + 1]**, ако върхът на T, отговарящ на A[i], има ляво дете.  
 - Елементът, който отговаря на **дясното дете на A[i], e A[2\*i + 2]**, ако върхът на T, отговарящ на A[i], има дясно дете.  

Нека A[0,..,n-1] е масив от ключове.  
***Пирамидална инверсия*** в A наричаме всяка наредена двойка индекси <i, j>, такива че i < j, A[i] е предшественик на A[j] и A[i] < A[j].  
***Масивът от ключове A е пирамида тогава и само тогава, когато няма нито една пирамидална инверсия.***  

## Бързо построяване на пирамида - алгоритъм Build Heap

В същината на алгоритъма Build Heap "стои" функцията **heapify**.  

![alt_text](https://i.ibb.co/cyMQCQv/heapify.png)

### Реализация на heapify

![alt_text](https://i.ibb.co/ZSSsZLV/heapify-1.png)

![alt_text](https://i.ibb.co/C5MMSCR/heapify-2.png)

![alt_text](https://i.ibb.co/H7frPr1/heapify-3.png)

***Сложност*** - O(log(n))  

### Реализация на Build Heap

```c++
BuildHeap(const vector<T>& v)
{
    for (size_t i = v.size() / 2 - 1; i >= 0; i--)
        heapify(i);
}
```

**Сложност** - O(n)  
(Доказва се чрез сходимост на степенни редове)  

## Приоритетна опашка (Priority queue)

Приоритетните опашки, подобно на пирамидите, са ***максимални*** и ***минимални***.  
Ние ще се съсредоточим върху **максимални** приоритетни опашки.  

Приоритетната опашка е абстрактна структура от данни (ADT), която очакваме да има следните функции в интерфейса си:  
- **max** - връща елемента с максимален ключ  
- **extractMax** - връща елемента с максимален ключ и го премахва  
- **insert** - вмъква елемент в опашката  

:bangbang: **Забележка** :bangbang:  
Ако в приоритетната опашка имаме елементи с еднакви ключове, **тя трябва да има поведението на "нормална" опашка (FIFO).**  

***Сложност на операциите:***  
max - **О(1)** :heavy_check_mark:  
extractMax - **О(log(n))** :heavy_check_mark:  
insert - **О(log(n))** :heavy_check_mark:  
