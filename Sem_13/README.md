# Хеш таблица (Hash table/Hash map)

## Въведение
Хеш таблицата е структура от данни, която се състои от наредени двойки **<ключ (key), стойност (value)>** или **само от ключове** (keys).  
При хеш таблицата имаме **хешираща функция**, която при подаден ключ генерира индекс **(хеш код/hash code)**, на който трябва да се запише съответната стойност (value). По принцип, този индекс е уникален. Може, обаче, да се случи генериране на един и същ хеш код за два различни ключа, което довежда до дублиране на индекси. Този проблем е познат като **„Колизия“ (“Collision”)**.  

![alt_text](https://i.ibb.co/GtPr2ky/Hash.jpg)

## Хеш функции
Какво наричаме **"добра" хеш функция**? - функция, при която има **малка вероятност за колизия**.  
- Функцията трябва да използва **всички данни от key**.  
- За **"подобни" ключове**, функцията връща **"напълно различни" индекси**.  
- **Равномерна функция** (Броят на колизиите на всеки индекс е относително еднакъв).  
- **Бърза за изчислване**. :exclamation:  

**"Перфектна" хеш функция - никога няма колизии!**  
В реалния свят, такава функция рядко е възможно да бъде създадена (възможните слотове обикновено са значително по- малко от възможните ключове).  
***Например***, ако множеството от ключовете са стрингове с дължина 20, съставени от буквите на английската азбука, то възможните стрингове са 26\^20, а възможните слотове - 4\*(10\^12). Следователно, по Дирихле, е невъзможно да нямаме колизия, ако хешираме повече от 4\*(10\^12) елемента.  

## Хеш таблици
1. **Основни операции**  
- insert(x)  
- find(x)  
- remove(x)  

2. **Видове**  
- С ключ и стойност (**map**)  
- Само ключ (**set**)  

3. **Предимства**  

||Worst case complexity|Expected complexity||
|--|--|--|--|
|insert|O(n)|O(1)|:heavy_check_mark:|
|find|O(n)|O(1)|:heavy_check_mark:|
|remove|O(n)|O(1)|:heavy_check_mark:|

4. **Недостатъци**  
- няма наредба  
- сложност на хеш-функцията  
- операциите не винаги са константни  
- преразход на памет  
- неудобно обхождане  

## Collision resolution strategies (CRS)

### Външно хеширане/Затворено адресиране (External Hashing/Closed addressing/Separate Chaining) - Данните са извън таблицата
Таблицата е масив от „кофи“ (buckets).  
Всяка кофа е отделен контейнер (най-често списък).  
**Преоразмеряване** на таблицата при запълване над 70% чрез прехеширане на всички елементи.  

:question: Нарича се ***затворено адресиране***, защото винаги x ∈ table[h(x)].  

![alt_text](https://i.ibb.co/G0Sh7sj/Open-hashing.png)

:heavy_check_mark: Общ брой елементи, по- голям от размера на таблицата, е ок.  
:heavy_check_mark: Лесно намираме всички елементи с даден ключ.  
:heavy_check_mark: Изтриването е лесно.  
:x: Индиректен достъп до елементите.  
:x: Повече памет.  

### Вътрешно хеширане/Отворено адресиране (Closed Hashing/Open addressing) - Данните са в таблицата
Таблицата съдържа всички елементи.  
За всяка клетка има допълнителни два флага – **empty** и **deleted**.  

 **Справяне с колизии**  
 • **Линейно пробване** - Стъпката S, която избираме, трябва да бъде взаимно проста с размера n на таблицата! **(S, n) = 1** :exclamation:  
 • **Квадратично пробване**  
 • **Двойно хеширане**  
 
Други стратегии – **Ку-Ку хеширане**  

**При вътрешното хеширане sizeof(table), n > броя елементи, cnt!** :exclamation:  
Препоръка: **n > 1,5*cnt**.  

![alt_text](https://i.ibb.co/F0YLZpF/Closed-hashing.png)

:heavy_check_mark: По- малко памет.  
:heavy_check_mark: Директен достъп по index.  
:x: По- трудно изтриване.  
:x: Неконсистентни позиции.  
