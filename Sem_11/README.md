**Разгледаните алгоритми са в папката на семинар 10!**  

## Задачи

**Задача 1 (Контролно 2019/20):** Нека имаме ориентиран граф от символи **g** и двоично дърво от символи **t**.  
Множеството от елементите на двете структури е едно и също, като в рамките на всяка една от структурите символите са уникални.  
Напишете функция, която *проверява дали съществува път от корена на дървото до листо, който да отговаря на път в графа*, и ако има такъв, го извежда.  
(*Заб.:* достатъчно е да изведете само един път, който отговаря на условието).  

***Пример:*** Пътят a - f - c - h отговаря на условието.  

![alt_text](https://i.ibb.co/HFJTk8d/Graph-Tree.png)

**Задача 2 (Контролно 2020/21):** Да се напише функция, която *проверява дали дърво с произволен брой наследници, погледнато отляво, е същото като погледнато отдясно*.  

**Задача 3 (Контролно):** Ниво L на двоично дърво съдържа всички възли на дървото, които се намират на разстояние L от корена на дървото.  
(*Заб.:* приемаме, че коренът е на ниво 0, преките му наследници - на ниво 1 и т.н.).  
Да се напише функция, която приема като параметри указатели към корените на две двоични дървета от цели числа и *проверява дали е вярно, че елементите на всяко ниво L на едното дърво съвпадат с елементите на съответното ниво L на другото дърво*.  

**Задача 4 (Контролно):** Създайте (чрез включване) _**двоично наредено дърво от интервали от числа ([a, b], a <= b)**_.  
Наредбата в дървото да бъде по *средната стойност на интервала*.  
Намерете *максималния интервал от дървото* (спрямо описаната наредба в него), *чието сечение с всеки един от другите интервали е непразно*, или върнете [0, 0], ако такъв няма.  
Използвайте *наредеността* на дървото, където е удачно.  

**Задача 5:** Да се напише функция, която приема двоично дърво от естествени числа и връща *дали в дървото има път от листо до друго листо, "минаващ" през корена, само с четни числа*.  

**Задача 6:** Да се напише функция, която приема двоично дърво T и двоично дърво R и *проверява дали R е поддърво на T*.  

**Задача 7:** Да се напише функция, която намира *сумата на най- големите елементи на отделни свързани компоненти в граф*.  

***Пример:***

![alt_text](https://i.ibb.co/6ss7NfH/Connected-components.png)
```c++
getSumOfMaxElInConnectedComp(g) // 26 (12 + 8 + 6)
```

**Задача 8:**  

***Разстояние на Хеминг*** между два стринга наричаме броя позиции, в които съотвените символи на стринговете са **различни**.  
*Например*, разстоянието на Хеминг между стринговете ***abcd*** и ***xbdc*** е 3 (Различават се на нулева, втора и трета позиции).  

Даден ни е "преобразувател" на стрингове, който може да _**конвертира стринг до друг стринг, променяйки само символите на първия (без дължината)**_. Преобразувателят има зададени правила, спрямо които да преобразува стрингове, и не може да прави никакви преобразувания, които ги няма в правилата.  

*Например*, даден ни е преобразувател с единствено правило "abc -> xby". Следователно, от "abc" можем да получим "xby" и нищо повече.  
Също така, ***всяко преобразуване има цена***, която е ***равна на разстоянието по Хеминг*** между двата стринга (подаденият и изходният).  

Разполагаме с множеството от инструкциите на преобразувател. Нашата задача е да напишем подходящо параметризирана функция *convertWithOptimalPrice()*, която приема два стринга и връща най- малката цена, с която можем да получим първия от втория (Правейки поредица от зададените ни правила).  

***Пример:***  
***Множеството от стрингове:***  
 *abcd, abzd, abzw, ayzw, xbzw, xazw, xyzw, ayzw, opqr*  
 
|Инструкции|Разстояние по Хеминг|
|--|--|
|abcd -> abzd|1|
|abzd -> abzw|1|
|abzw -> ayzw|1|
|abcd -> xbzw|3|
|xbzw -> xazw|1|
|xazw -> xyzw|1|
|ayzw -> xyzw|1|
|abcd -> opqr|4|

***Начини да получим xyzw от abcd (Използвайки само дадените правила):***  
- abcd -> xbzw -> xazw -> xyzw (Цена: 3 + 1 + 1 = 5)  
- abcd -> abzd -> abzw -> ayzw -> xyzw (Цена: 1 + 1 + 1 + 1 = 4)  

```c++
convertWithOptimalPrice(abcd, xyzw); // 4
```
