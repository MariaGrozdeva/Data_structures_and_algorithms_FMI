# Двоична пирамида. Приоритетна опашка

## Двоична пирамида (Binary heap)

***Дефиниция:*** **Попълнено двоично дърво (Complete binary tree)** е наредено двоично дърво, в което:  
- Всички нива, с изключение, може би, на последното, имат максималния възможен брой върхове.  
- Ако листата са на две нива, листата на последното ниво са максимално вляво.  

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_09/images/CompleteBinaryTree.png)

***Дефиниция:*** **Двоична пирамида (Binary heap)** е попълнено двоично дърво, в което:  
- Или ключът на всеки връх е *по-голям или равен* на ключовете на неговите деца и тогава пирамидата е _**максимална пирамида (max heap)**_,  
- или ключът на всеки връх е *по-малък или равен* на ключовете на неговите деца и тогава пирамидата е _**минимална пирамида (min heap)**_.  

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_09/images/BinaryHeap.png)

## Реализация на двоична пирамида

Ще реализираме двоична пирамида *чрез масив*, който ще наричаме ***линеаризация*** на пирамидата.  
Линеаризирането можем да си представяме като обхождане на дървото (пирамида) по нива отляво надясно и последователно записване на ключовете в масива.  
Например, линеаризация на пирамидата от горната картинка е масивът **[10, 8, 9, 3, 2, 1]**.  

Тъй като дървото е попълнено, в масива няма как да има "дупки".  
***Предимството на тази реализация е, че се избягва разхода на памет.*** Ако искаме да представим двоично дърво в общия случай, не непременно попълнено, трябва по някакъв начин да укажем за всеки връх кой е родителят или кои са децата. Това ни струва допълнителна памет.  

Нека T е пирамида с n елемента и масивът A[0,..,n-1] е нейната линеаризация. Тогава за всеки елемент A[i]:  
 - Елементът, който отговаря на **родителя на A[i], e A[(i - 1) / 2]**, ако върхът на T, който отговаря на A[i], не е коренът.  
 - Елементът, който отговаря на **лявото дете на A[i], e A[2\*i + 1]**, ако върхът на T, отговарящ на A[i], има ляво дете.  
 - Елементът, който отговаря на **дясното дете на A[i], e A[2\*i + 2]**, ако върхът на T, отговарящ на A[i], има дясно дете.  

Нека A[0,..,n-1] е масив от ключове.  
***Пирамидална инверсия*** в A наричаме всяка наредена двойка индекси <i, j>, такива че i < j, A[i] е предшественик на A[j] и A[i] < A[j].  
***Масивът от ключове A е пирамида тогава и само тогава, когато няма нито една пирамидална инверсия.***  

## Бързо построяване на пирамида - алгоритъм Build Heap

В същината на алгоритъма Build Heap "стои" функцията **heapify**.  

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_09/images/heapify.png)

### Реализация на heapify

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_09/images/heapify-1.png)

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_09/images/heapify-2.png)

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_09/images/heapify-3.png)

***Сложност*** - $\Theta(\log n)$

### Реализация на Build Heap

```c++
BuildHeap(const std::vector<T>& v)
{
    for (size_t i = v.size() / 2 - 1; i >= 0; i--)
    {
        heapify(i);
    }
}
```

**Сложност** - $\Theta(n)$

---

## Приоритетна опашка (Priority queue)

Приоритетната опашка е абстрактна структура от данни (ADT), която очакваме да има следните функции в интерфейса си:  
- **top** - връща елемента с най- висок приоритет - $\Theta(1)$
- **push** - вмъква елемент - $\Theta(\log n)$
- **pop** - премахва елемента с най- висок приоритет - $\Theta(\log n)$

:bangbang: **Забележка** :bangbang:  
Ако в приоритетната опашка имаме елементи с еднакви ключове, **тя трябва да има поведението на "нормална" опашка (FIFO).**  
