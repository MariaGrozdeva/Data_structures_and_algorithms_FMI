# Хеш таблици

## Въведение
Хеш таблицата е структура от данни, която се състои от наредени двойки **<ключ (key), стойност (value)>** или **само от ключове** (keys).  
При хеш таблицата имаме **хешираща функция**, която при подаден ключ генерира индекс **(хеш код/hash code)**, на който трябва да се запише съответната стойност (value). По принцип, този индекс е уникален. Може, обаче, да се случи генериране на един и същ хеш код за два различни ключа, което довежда до дублиране на индекси. Този проблем е познат като **колизия (collision)**.  

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_10/images/Hash.jpeg)

## Хеш функции
- Функцията трябва да е детерминистична, т.е. ако $x = y$, то $hash(x) = hash(y)$.
- Трябва да използва всички данни от key.
- За "подобни" ключове, функцията връща "напълно различни" индекси.
- Равномерна функция (броят на колизиите на всеки индекс е относително еднакъв).
- Бърза за изчислване. :exclamation:  

**"Перфектна" хеш функция - никога няма колизии!**  
В реалния свят такава функция рядко е възможно да бъде създадена (възможните слотове обикновено са значително по- малко от възможните ключове).  
Например, ако множеството от ключовете са стрингове с дължина $20$, съставени от буквите на английската азбука, то възможните стрингове са $26^{20}$, а възможните слотове - около $4\*10^{12}$. Следователно е невъзможно да нямаме колизия, ако хешираме повече от $4\*10^{12}$ елемента.  

## Хеш таблици
### Основни операции:
- insert(x) - $\Theta(1)$ :heavy_check_mark:
- find(x) - $\Theta(1)$ :heavy_check_mark:
- remove(x) - $\Theta(1)$ :heavy_check_mark:

### Видове:
- с ключ и стойност (**map**)
- само ключ (**set**)

### Недостатъци:
- няма наредба
- сложност на хеш-функцията
- операциите не винаги са константни
- преразход на памет
- неудобно обхождане

## Collision resolution strategies (CRS)
### 1. `Външно хеширане/Затворено адресиране` (External Hashing/Closed addressing/Separate Chaining) - данните са извън таблицата
Таблицата е масив от „кофи“ (buckets).  
Всяка кофа е отделен контейнер (най-често списък).  
Преоразмеряване на таблицата при запълване над 70% чрез прехеширане на всички елементи.  

:question: Нарича се ***затворено адресиране***, защото винаги $x \in table[h(x)]$.  

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_10/images/OpenHashing.png)

:heavy_check_mark: Общ брой елементи, по- голям от размера на таблицата, е ок.  
:heavy_check_mark: Лесно намираме всички елементи с даден ключ.  
:heavy_check_mark: Изтриването е лесно.  
:x: Индиректен достъп до елементите.  
:x: Повече памет.  

### 2. `Вътрешно хеширане/Отворено адресиране` (Closed Hashing/Open addressing) - данните са в таблицата
Таблицата съдържа всички елементи.  
За всяка клетка има допълнителни два флага – *empty* и *deleted*.  

 ### Справяне с колизии
 - **Линейно пробване** - Стъпката S, която избираме, трябва да бъде взаимно проста с размера n на таблицата! **$(S, n) = 1$** :exclamation:
 - **Квадратично пробване**
 - **Двойно хеширане**
 
Други стратегии – **Ку-Ку хеширане**  

При вътрешното хеширане sizeof(table), n > броя елементи, cnt! :exclamation:  
Препоръка: $n > 1,5\*cnt$.  

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_10/images/ClosedHashing.png)

:heavy_check_mark: По- малко памет.  
:heavy_check_mark: Директен достъп по index.  
:x: По- трудно изтриване.  
:x: Неконсистентни позиции.  

---

## Задачи

[1. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)  
[2. 0-1 Subarray](https://www.hackerrank.com/contests/sda-homework-9/challenges/0-1-1)  
[3. Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/description/)  
