# Свързан списък

Структурата данни *"Свързан списък"* представлява поредица от елементи, като всеки от тях съдържа не само информацията, която бихме пазили в масив, ами и информация кой е *следващият (и предишният)* елемент в поредицата.  
В най-стандартната имплементация, тази информация представлява указател към следващия (и предишния) елемент. Така лесно можем да обходим всички елементи от структурата - започвайки от първия, следваме неговия указател към следващия, от там към по-следващия и т.н.  
Допълнително ще пазим два указателя - към първия и към последния елемент на списъка. Това ще ни позволява лесно да добавяме елемент както в началото, така и в края на списъка.  
 
## Едносвързан списък (Singly Linked List)

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_04/images/SLL.png)

### Сложност на операциите му:
- Добавяне на елемент в началото -> **$\Theta(1)$**.
- Добавяне на елемент в края -> **$\Theta(1)$**.
- Премахване на елемент от началото -> **$\Theta(1)$**.
- Добавяне на елемент **след** произволна позиция, към която имаме итератор -> **$\Theta(1)$**.
- Премахване на елемент **след** произволна позиция, към която имаме итератор -> **$\Theta(1)$**.
- Всичи останали добавяния/премахвания -> **$\Theta(n)$**.

## Двусвързан списък (Doubly Linked List)
 
### Сложност на операциите му:
- Добавяне на елемент в началото -> **$\Theta(1)$**.
- Добавяне на елемент в края -> **$\Theta(1)$**.
- Премахване на елемент от началото -> **$\Theta(1)$**.
- Премахване на елемент от края -> **$\Theta(1)$**.
- Добавяне на елемент на произволна позиция, към която имаме итератор -> **$\Theta(1)$**.
- Премахване на елемент от произволна позиция, към която имаме итератор -> **$\Theta(1)$**.

---

## Задачи

### Задача 1: Quick sort на списък.

### Задача 2: Merge sort на списък.

### Задача 3: Flatten на списък.

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_04/images/Multilevel-list.png)

![alt text](https://github.com/MariaGrozdeva/Data_structures_and_algorithms_FMI/blob/main/Sem_04/images/One-level-list.png)

### Задача 4:
Даден е едносвързан **цикличен** списък, чиито елементи са стрингове.  
Да се реализира функция *unite(Node\* list)*, която получава като параметър указател към елемент на цикличния списък от стрингове и обединява всички двойки последователни елементи на списъка, за които последния символ на единия елемент съвпада с първия символ на непосредствено следващия му елемент, в общ елемент, чийто низ е съставен от слепването на стринговете на двата елемента, разделени с тире.  
Функцията да изкарва списъка на стандартния изход, започвайки от лексикографски най-малкия низ.  

Вход:  
```c++
street -> taxi -> ink -> dog -> smile -> eat -> tall -> pass
```
Изход:  
```c++
dog

smile -> eat -> tall

pass -> street -> taxi -> ink
```

### Задача 5:
Даден е списък **l** с елементи списъци от естествени числа в интервала [0,..,9]. От всеки списък $l_i$ получаваме две числа по следния начин:  
- Обхождайки го отпред назад, получваме число $n_i$.  
- Обхождайки го отзад напред, получаваме число $n_{i_{reversed}}$.  

Да се дефинира функция, която намира сумата $n_i$ + $n_{i_{reversed}}$ за 0 <= i <= l.size() - 1.  

*Вход:* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Изход:*
```c++
1 -> 2                        809
|                             (12 + 21 + 234 + 432 + 55 + 55)
v
2 -> 3 -> 4
|
v
empty
|
v
5 -> 5
```


### Задача 6
Даден е списък **l** с n елемента.  
Да се дефинира функция *shuffle()*, която получава адреса на първия елемент на списъка. Функцията да пренарежда възлите на списъка така, че *елементите от втората половина на списъка да се преместят в началото на списъка, но в обратен ред* (при списъци с нечетен брой елементи считаме средния елемент за принадлежащ към първата половина на списъка).  

*Пример:*
*L1 → L2 → L3 → L4 → L5 се преобразува до L5 → L4 → L1 → L2 → L3*  
